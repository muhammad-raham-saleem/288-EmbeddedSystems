//Author: Muhammad Raham Saleem
//contributors: Connor Crimmins
//applies to the movement.c file where the robot is moved by a specific distance
#include "movement.h"
#include "open_interface.h"
#include "lcd.h"


double move_forward(oi_t *sensor_data, double distance_mm){
double sum =0;
double backingUp=0;
double remainingDist=2000;
double distanceTravelled=0;
char whichBumpHit[] ="";

//start moving
oi_setWheels(100,100);

//loop until distance is reached
while(sum<distance_mm){

    //update the sensor data 
    oi_update(sensor_data);

    //this adds the distance travelled in mm since the last call
    sum += sensor_data->distance;

    //collison detection and stops if a bumper is hit
    if(sensor_data->bumpLeft || sensor_data->bumpRight){
        if(sensor_data->bumpLeft){
            whichBumpHit="L";
        }
        if(sensor_data->bumpRight){
            whichBumpHit="R";
        }
        lcd_clear();
        lcd_printf("Obstacle Detected");
        oi_setWheels(0,0);
        oi_update(sensor_data);
        distanceTravelled+=sensor_data->distance;
        lcd_clear();
        lcd_printf("Backing up!");
        oi_setWheels(-100,-100);
        while(backingUp<150){
            oi_update(sensor_data);

            backingUp+=fabs(sensor_data->distance);
        }
        oi_setWheels(0, 0);
        if(whichBumpHit=="R"){
            lcd_clear();
            lcd_printf("right bump detected");
       turn_right(sensor_data,-90);
         move_forward(sensor_data,250);
         turn_left(sensor_data,90);
        }
        if(whichBumpHit=="L"){
            lcd_clear();
            lcd_printf("left bump detected");
            turn_left(sensor_data,90);
             move_forward(sensor_data,250);
             turn_right(sensor_data,-90);
        }

       //distance travlled should not be more than remaining
        lcd_clear();
        lcd_printf("covering remaining distance");
        move_forward(sensor_data,remainingDist-distanceTravelled);

    }
}
oi_setWheels(0, 0); //stop when distance is reached
return sum;
}
double turn_right(oi_t *sensor, double degrees){
    double startAngle=sensor->angle;
    double angleDifference=0;
    degrees=degrees*0.9;

    oi_update(sensor);
    oi_setWheels(-100,100);
    angleDifference+=(fabs(sensor->angle)-fabs(startAngle));


    while(angleDifference < fabs(degrees)){

        oi_update(sensor);
        angleDifference+=(fabs(sensor->angle)-fabs(startAngle));

    }
    oi_setWheels(0,0);
        return angleDifference;
}
double turn_left(oi_t *sensor, double degrees){
    double startAngle=sensor->angle;
      double angleDifference=0;
      degrees=degrees*0.9;

      oi_update(sensor);
      oi_setWheels(100,-100);
      angleDifference+=(fabs(sensor->angle)-fabs(startAngle));


      while(angleDifference < fabs(degrees)){

          oi_update(sensor);
          angleDifference+=(fabs(sensor->angle)-fabs(startAngle));

      }
      oi_setWheels(0,0);
          return angleDifference;
}
